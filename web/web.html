<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ESP32 Audio Recorder</title>
  </head>
  <body>
    <h1>ESP32 Audio Recorder</h1>

    <div>
      <button id="connectBtn">Connect BLE</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <br />
    <div>
      <button id="recordBtn" disabled>Record</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <p>Status: <span id="status">Disconnected</span></p>
    <p>Samples recorded: <span id="sampleCount">0</span></p>

    <audio id="audioPlayer" controls></audio>

    <script>
      const SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
      const TX_CHAR_UUID = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; // notify: ESP32 -> browser

      const connectBtn = document.getElementById("connectBtn");
      const disconnectBtn = document.getElementById("disconnectBtn");
      const recordBtn = document.getElementById("recordBtn");
      const stopBtn = document.getElementById("stopBtn");
      const statusDisplay = document.getElementById("status");
      const sampleCountDisplay = document.getElementById("sampleCount");
      const audioPlayer = document.getElementById("audioPlayer");

      let device = null;
      let charRx = null;
      let isRecording = false;
      let recordedSamples = [];

      connectBtn.addEventListener("click", async () => {
        try {
          if (!navigator.bluetooth) {
            throw new Error("Web Bluetooth not supported");
          }

          statusDisplay.textContent = "Requesting device...";
          device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [SERVICE_UUID] }],
          });

          statusDisplay.textContent = "Connecting...";
          const server = await device.gatt.connect();
          const service = await server.getPrimaryService(SERVICE_UUID);

          charRx = await service.getCharacteristic(TX_CHAR_UUID);

          await charRx.startNotifications();
          charRx.addEventListener("characteristicvaluechanged", handleNotification);

          device.addEventListener("gattserverdisconnected", () => {
            statusDisplay.textContent = "Disconnected";
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            recordBtn.disabled = true;
            stopBtn.disabled = true;
            isRecording = false;
          });

          statusDisplay.textContent = "Connected";
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
          recordBtn.disabled = false;
        } catch (err) {
          console.error("Error:", err);
          statusDisplay.textContent = "Error: " + err.message;
        }
      });

      disconnectBtn.addEventListener("click", () => {
        if (device && device.gatt.connected) {
          device.gatt.disconnect();
        }
        statusDisplay.textContent = "Disconnected";
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        recordBtn.disabled = true;
        stopBtn.disabled = true;
        isRecording = false;
      });

      recordBtn.addEventListener("click", () => {
        recordedSamples = [];
        sampleCountDisplay.textContent = "0";
        isRecording = true;
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        statusDisplay.textContent = "Recording...";
        audioPlayer.src = "";
      });

      stopBtn.addEventListener("click", () => {
        isRecording = false;
        recordBtn.disabled = false;
        stopBtn.disabled = true;
        statusDisplay.textContent = "Stopped. Processing audio...";
        createWavFile(recordedSamples);
      });

      function handleNotification(event) {
        // Decode binary data as 16-bit signed integers (little-endian)
        const dataView = new DataView(event.target.value.buffer);
        const sampleCount = dataView.byteLength / 2;

        for (let i = 0; i < sampleCount; i++) {
          const sample = dataView.getInt16(i * 2, true); // little-endian

          if (isRecording) {
            recordedSamples.push(sample);
          }
        }

        if (isRecording && recordedSamples.length % 1000 < sampleCount) {
          sampleCountDisplay.textContent = recordedSamples.length;
        }
      }

      function createWavFile(samples) {
        const sampleRate = 16000;
        const numChannels = 1;
        const bitsPerSample = 16;

        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);

        writeString(view, 0, "RIFF");
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * 2, true);
        view.setUint16(32, numChannels * 2, true);
        view.setUint16(34, bitsPerSample, true);
        writeString(view, 36, "data");
        view.setUint32(40, samples.length * 2, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++) {
          view.setInt16(offset, samples[i], true);
          offset += 2;
        }

        const blob = new Blob([view], { type: "audio/wav" });
        const url = URL.createObjectURL(blob);
        audioPlayer.src = url;
        statusDisplay.textContent = "Audio loaded";
      }

      function writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      }
    </script>
  </body>
</html>
